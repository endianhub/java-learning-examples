## 动态代理

#### 代理模式整个应用场景

1. 打印日志
2. Rpc的远程调用框架
3. Mybatis mapper
4. Aop
5. 事务 
6. 自定义注解
7. 分布式事务全局id lcn seata 生成一个全局的事务id
8. SpringBoot全局捕获异常

<br>

#### 代理模式优点

1. 减少代码冗余，提高代码复用性；
2. 安全性高，隐藏真实角色、防止非法侵入。

<br>

#### 代理实现方式

1、静态代理与动态代理

- 静态代理：也需要开发者自己编写代理类
- 静态的实现方式：1.实现接口（Jdk实现）2通过继承模式（Cglib）

2、动态代理设计需要写代理，统一采用程序生成

<br>

#### 静态代理模式缺陷

- 需要每次人工编写代理类对象，代码非常冗余

<br>

#### 动态代理模式

- Jdk动态代理：采用实现接口模式实现增强，基于回调拦截，使用反射技术执行目标方法
- CGLIB动态代理：采用继承模式实现增强

最大优势：不需要些代理类对象通过程序生成

JDK 动态代理实现方式 InvocationHandler 接口重写 invoke 方式实现回调形式实现增强 - 拦截方式。

JDK 动态代理生成的 $Proxy0 类可以强制成接口类型，但是不能强制实现；JDK 动态代理以$Proxy开头。

<br>

#### 手写 JDK 动态代理设计模式思路
1. 使用java反射机制获取当前接口的信息javase反射机制
2. 拼接java代码，将java代码写入在本地文件
3. 将java代码编译为class文件
4. 程序直接读取该class文件到内存中即可。

<br>

**手写 JDK 动态代理实现思路**

1. 使用java反射机制拼接$Proxy.java类的源代码
2. 需要将$Proxy.java编译成$Proxy.class
3. 程序中直接读取该class文件到内存中

<br>

#### 静态单例
- 继承
- 实现

